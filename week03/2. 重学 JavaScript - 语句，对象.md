# 02.重学 JavaScript | 语句，对象

[toc]

## Statement 语句

- 在 JS 中我们怎么去定义、理解语句。

![image-20200428205533479](assets/image-20200428205533479.png)

首先我们来讲语句分个类，在 Grammar 层面有三种分类：

- 简单语句
  - 只有一句，比如调用 `foo()` 
- 组合语句
  - 可以嵌套简单语句
- 声明
  - 会产生特殊行为



### Runtime

除了我们之前所说的八种从语法层面来说的数据类型之外，在 Runtime 中还有很多**内置类型**，虽然这些类型我们在写代码时碰不到，但当程序运行时它们却确实存在于内存之中。



两个概念：

- Completion Record
  - 早期版本就叫 Completion，指语句的执行结果
- Lexical Enviorment
  - 初始词法环境



#### Completion Record

![image-20200428210109744](assets/image-20200428210109744.png)

这个类型有三个字段：

- [[type]]；语句完成的类型，有五种取值，对应四个语句（除 normal 之外的）。
- [[value]]；之前所讲的八种语言类型。除此之外还有空值 `empty` 
  - 目前，只有 `throw` 和 `return` 会带这个字段
- [[target]]；一定是个 label

这些都是指**语句完成后**状态的描述。虽然 Completion Record 如果不去读规范，可能都不知道有这么个东西，但是它却在影响着语句的行为。之后也会在不同的语句中讲解它是如何发挥作用的。（以下简称 CR）



### 简单语句

![image-20200428211329682](assets/image-20200428211329682.png)

其中三个产生 normal，四个产生非 normal。

复杂语句中都是根据其产生的 type 来决定自己的执行过程。 

#### ExpressionStatement（表达式语句）

表达式本身就可以构成一个语句，也是语句中最主体的部分，其告诉计算机做运算。

```js
a = 1 + 2;
```



#### EmptyStatement（空语句）

也就是一个分号 `;` 

```js
;
```



#### DebuggerStatement（调试语句）

`debugger` 这个语句对于运行时而言不会发生任何作用，比如用户的电脑上，但是其在控制台中用于调试，产生中断，是规范留给引擎去实现的一个东西。

```js
debugger
```



#### ThrowStatement

其后面可以跟一个表达式

```JS
throw a;
```



#### ContinueStatement

```js
continue;
// or
continue [label1];
```

- 可带 `label` 

#### BreakStatement

```js
break;
// or
break [label2];
```

- 可带 `label`

#### ReturnStatement

其后面可以跟一个表达式

```js
return 1 + 2;
```



### 复合语句

![image-20200428212103410](assets/image-20200428212103410-1588080067883.png)

#### BlockStatement

![image-20200428212144277](assets/image-20200428212144277.png)

- 其由一对 `{}` 括起来构成，和对象的直接量构成方式相同。

- 会将多条语句括起来之后变成像是一条语句。所以它是形成我们语句非常关键的一个因素。

- 在最新的 ECMA 中，还能为 `let` 和 `const` 提供作用域。所以你可以在控制台中这样写代码：

  ```JS
  {
    const a = 1;
  }
  
  {
    const a = 1;
  }
  ```

- 正常情况下 BlockStatement 的执行结果就是 normal，但如果其内部 statement list 中的语句产生了非 normal 的结果则执行过程会被中断，比如：

  ```js
  {
    const a = 1;
    throw 1;
    const b = 2;
    console.log(b)
  }
  ```

  - 这里因为 `throw 1` 语句而中断了 block 语句的中的执行过程。

  - 这也是 `throw` `continue` `break` `return` 能够改变代码、语句执行顺序的基础逻辑，都在 block 中。

  - 不过对于 `continue` `break` `return` 需要在特定的语句下才能执行，比如 `continue` 需要在迭代语句中。否则会报：

    ```
    Uncaught SyntaxError: Illegal continue statement: no surrounding iteration statement
    ```

- blockstament 虽然很简单，其 block 内的语句是顺次执行，但如果其中某个语句产生了非 normal 的结果，就会打断这样的执行状态，从而能够产生代码结构化的特点（不是很懂，这个后面应该在讲代码结构化的部分会讲到）。

- 从这里我们可以看出，CR 的 type 是非常重要的东西，能够控制语句执行不执行，怎么执行。



#### Iteration

![image-20200428213817899](assets/image-20200428213817899.png)

这里先讲前 5 种，`for await(of)` 等着之后讲结构化，promise 的部分再展开。

Iteration 语句和别的语句不同的是，语句可以执行多次，而其他的只会执行一次。

上面偏黑色的部分可以声明变量，稍浅的部分可以放表达式，再浅的部分可以放 block statement

- `while` 是由一个表达式 + 语句的结构，由于有 block 语句的存在，所以其可以有多个简单语句。`while` 有个特点，如果其内部语句的 CR type 是 `continue` 或者 `break`，`while` 会将其消费掉。而不是简单的跳出这个语句，也就是说如果子语句出现 `continue` 或者 `break` 就会做相应的处理。如果是 `break` 就不执行了，`continue` 则中断这一次的 block，跳过这一次循环。

  - 如果 `break` 和 `continue` 的 CR 带有 label，则会由 `lable` 所指定的目标语句来消费。目前，`lable` 只有在循环语句中有作用。

- `do...while` 和 `while` 基本相同，只是多执行一遍语句。

- `for` 很特殊，上图中的偏黑部分可以放声明（`let` `const` `var`），对于 `var` 的声明都还好，因为其产生的变量只会在函数中产生作用域，而 `let` `const` 就会产生作用域，其范围在 block 之外。

  ```js
  for(let i = 0; i < 10; i++){
    console.log(i);
  }
  // => 0 1 2 3 4 5 6 7 8 9
  
  for(let i = 0; i < 10; i ++){
    let i = 0
    console.log(i);
  }
  
  // => (10) 0 
  
  {
    let i = 0;
    if(i < 10){
      let i = 0
    	console.log(i);
    }
    i ++
  }
  ```

  - 在第二个 for 循环的语句中，我们重新声明了一个 `i` 但是并没有报错，说明并不是在 block 中声明的。
  - 可以试想是在 block 之外还有一个 block，在那里声明了一个 i 

  - `let i = 0; i < 10; i ++` 这三句话可以理解为在循环外层有一个副作用域，如上 13 行开始的代码。

- `for in` 和 `for of` 在语句结构层面完全类似
  
  -  `for in`  循环一个对象的所有属性
- 而 `for of` 就稍微比较复杂，对任何可迭代属性的对象进行迭代，可以将其理解为一个语法糖，相当于调用了对象上的一个方法。
  
- `in` 运算符和 `for in` 中的 `in` 有语法冲突，所以 `for in` 中的表达式是不能出现 `in` 的，那么语法的规范中就出现了两种表达式，带 `in` 和不带 `in` （会有 ?in 的表示）



#### 标签、循环、break、continue

![image-20200429101601352](assets/image-20200429101601352.png)

所有的语句都可以加标签变成 `LabelledStatement` ，而只有 `IterationStatement` 和 `SwitchStatement` 语句能够消费标签的语句。

虽然所有的语句都可以支持添加标签，但是并不会有任何的作用，所以有些人会将这个特性用于在代码可读性上来帮助自己区别，比如：

```js
function Parent(){
  public:
  	this.a = a;
  	this.b = b;
  private:
  	var x = 3;
  	var y = 4;
}
```

- 在还没有 `class` 的时候，通过标签来区分公有成员和私有成员。
- 但是对于协同开发的项目来说，如果不事先有一个开发规范，那么就会使和你一起协同开发的人搞不清楚这是什么。
- winter 不推荐写这样模仿外观但却没有任何功能的代码，我们应该追求的是**表达能力**相近而不是长相相近。比如函数式编程，我们用 JS 的语法特性来实现其编程的能力，这样才有意义，改变外观会造成混淆和难以调试，并且可能会面对因为未来的更新造成程序出错。

LabelledStatement 其实非常的不常用，并且很多代码规范不推荐使用它。虽然使用它能够提升一些性能，但是这点性能实际上太小而没有多大意义，并且会让很多人读代码的过程中产生疑惑🤔。

#### try

![image-20200429104857061](assets/image-20200429104857061.png)

- try 是 js 语句中行为最为复杂的例子

- 每一个语句都需要带有花括号

- 除了 `throw` 语句之外，还有其他的语句能够产生 `throw` 的执行结果吗？

  - ExpressionStatement 可能会产生，比如 `1 = a` 所产生运行时错误。

- `catch` 后小括号的那部分所接受的变量和花括号共用一个作用域。

  - **作用域**是从语言的角度来描述，并不关心运行时和底层机制或是背后思想，只关心声明的变量有效的范围。

  ```js
  try{
      throw 1;
  }catch(e){
      let e = 1;
      console.log('catch')
  }
  // Uncaught SyntaxError: Identifier 'e' has already been declared
  ```

  - 可以看到在 `catch` 之后的语句块中我们重新声明变量 `e` 报错了，提示我们已经声明过。这个行为和 `for` 中声明的不同，和函数很像。

作用域与上下文的区别？

- 作用域指的是程序员电脑上，源代码中文本的范围。比如：

  ```js
  try{
      throw 1;
  }catch(e){
      console.log('catch')
  }
  ```

  - 这里 `e` 就只能作用于后面的 block 之中的文本区域。

- 执行上下文指在用户的电脑上，内存中存变量的地方，JS 在执行的时候，所需要的对象。

- ES3 中使用 `scope` 这个词来指代用户内存中的对象，新版换成了 `lexical environment`



### 声明（一种机制）

![image-20200429142823053](assets/image-20200429142823053.png)

#### FunctionDeclaration

```js
function foo(){
  
}
```

- 需要 `function` 关键字和名称
- `function` 位于语句开头，IIFE 是表达式，因为语句的开头并不是 `function` 关键字

下面这个是函数表达式，不要和函数声明混淆，完全不同：

```js
const foo = function (){
  
}
```

- 可以没有名称，并且也可以形成 IIFE

同理 ClassDeclaration 一样

#### ClassDeclaration

```js
class Cat{
  
}

const Dog = class {}
```

- 上面的类声明不允许缺少名称，会报错。

#### GeneratorDeclaration

```js
function *gen(){
  let i = 0;
  yield 1;
  yield 2;
  while(true){
    yield i++
  }
}
```

- Generator 可以理解为特殊的 function，其内部可以使用 `yield` 
- generator 可以用于模拟 await
- 标准的 generator 的用法就是向上面那样产生无尽的序列，或是分步返回多个值。
- Generator 和 Function 特性基本相同，比如可以有表达式
- 它属于结构化编程的一部分，所谓结构化编程就是我为你提供各种结构化的表达能力，比如对象、函数、过程等等，通过提供这些东西让你的表达更接近于自然的思维。比如，有 `while` 这种循环了，为什么还要搞其他的 `do...while` `for` ，明明 `while` 也能实现它们的能力，说白了就是提供多一个选项，从而你能够选择多一种「词汇」来进行表达，和写文章的词汇量一样。当然，前提是你和你的读者要对这不同的「词汇」有足够的理解，才能使表达更清晰而不含混。

#### AsyncFunctionDeclaration

为什么说异步很重要？

- 和性能没有关系，主要是代码结构的问题。

- 比如我们写一个时钟：

  ```js
  function tick(){
      var i = 0;
      setInterval(function(){
          console.log(i++)
      },1000)
  }
  ```

  - 上面是使用普通的函数，然后里面调用 `setInterval` 的方式

  ```js
  function sleep(m){
    return new Promise(resolve => {
  		setTimeout(resolve, m);
    })
  }
  
  void async function(){
    let i = 0;
    while(true){
      await sleep(1000)
      console.log(i++);
    }
  }();
  ```

  - 虽然和上面的效果相同，但是看起来更像是同步代码，就是等上面 `await` 执行完之后再执行后面的代码。

#### AsyncGeneratorDeclaration

```js
function sleep(m){
  return new Promise(resolve => {
		setTimeout(resolve, m);
  })
}

async function *gen(){
  let i = 0;
  while(true){
    yield i++
    await sleep(1000);
  }
}

void async function(){
  var g = gen();
  for await(let e of g){
    console.log(e)
  }
}()
```

- 具有 `Async` 和 `Generator` 两种函数的功能
- `for await` 就是为 `AsyncGeneratorDeclaration` 设计的。





## 课程涉及内容

### 课后作业：

- 找出 JavaScript 标准里有哪些对象是我们无法实现出来的，都有哪些特性？写一篇文章，放在学习总结里。

### 有助于你理解的知识：

- 按照 ECMAScript 标准，一些特定语句（statement) 必须以分号结尾。分号代表这段语句的终止。但是有时候为了方便，这些分号是有可以省略的。这种情况下解释器会自己判断语句该在哪里终止。这种行为被叫做 “自动插入分号”，简称 ASI (Automatic Semicolon Insertion) 。实际上分号并没有真的被插入，这只是个便于解释的形象说法。
- `var` 最好写在函数内最前面或变量第一次出现的地方

